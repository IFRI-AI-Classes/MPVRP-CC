<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VRP Solution Visualizer | Petroleum Distribution</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Dark Theme (Default) */
            --bg-color: #0a0a0f;
            --card-bg: #12121a;
            --card-bg-hover: #1a1a25;
            --primary: #6366f1;
            --primary-glow: rgba(99, 102, 241, 0.4);
            --secondary: #22d3ee;
            --secondary-glow: rgba(34, 211, 238, 0.3);
            --accent: #f472b6;
            --success: #34d399;
            --warning: #fbbf24;
            --danger: #f87171;
            --text: #f1f5f9;
            --text-muted: #94a3b8;
            --text-dim: #64748b;
            --border: rgba(255,255,255,0.08);
            --border-light: rgba(255,255,255,0.12);
            --input-bg: #1e1e2a;
            --shadow: 0 25px 50px -12px rgba(0,0,0,0.6);
            --shadow-glow: 0 0 40px var(--primary-glow);
            --map-bg: linear-gradient(145deg, #0d0d14 0%, #111118 100%);
            --node-bg: #1e1e2a;
            --grid-color: rgba(255,255,255,0.03);
        }

        [data-theme="light"] {
            --bg-color: #f8fafc;
            --card-bg: #ffffff;
            --card-bg-hover: #f1f5f9;
            --primary: #4f46e5;
            --primary-glow: rgba(79, 70, 229, 0.2);
            --secondary: #0891b2;
            --secondary-glow: rgba(8, 145, 178, 0.15);
            --accent: #db2777;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --text: #0f172a;
            --text-muted: #475569;
            --text-dim: #94a3b8;
            --border: rgba(0,0,0,0.08);
            --border-light: rgba(0,0,0,0.12);
            --input-bg: #f1f5f9;
            --shadow: 0 25px 50px -12px rgba(0,0,0,0.15);
            --shadow-glow: 0 0 40px var(--primary-glow);
            --map-bg: linear-gradient(145deg, #ffffff 0%, #f8fafc 100%);
            --node-bg: #ffffff;
            --grid-color: rgba(0,0,0,0.04);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-color);
            color: var(--text);
            min-height: 100vh;
            overflow: hidden;
        }

        /* Animated Background */
        .bg-pattern {
            position: fixed;
            inset: 0;
            background-image: 
                radial-gradient(circle at 20% 80%, var(--primary-glow) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, var(--secondary-glow) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        .container {
            position: relative;
            z-index: 1;
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
            display: grid;
            grid-template-columns: 320px 1fr;
            grid-template-rows: auto 1fr auto;
            gap: 20px;
            height: 100vh;
        }

        /* Header */
        .header {
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 24px;
            background: var(--card-bg);
            border-radius: 16px;
            border: 1px solid var(--border);
            backdrop-filter: blur(20px);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 14px;
        }

        .logo-icon {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            box-shadow: 0 8px 20px var(--primary-glow);
        }

        .logo-text h1 {
            font-size: 20px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--text) 0%, var(--text-muted) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .logo-text span {
            font-size: 12px;
            color: var(--text-dim);
            font-weight: 500;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .theme-toggle {
            width: 44px;
            height: 44px;
            border-radius: 12px;
            border: 1px solid var(--border);
            background: var(--input-bg);
            color: var(--text);
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .theme-toggle:hover {
            background: var(--card-bg-hover);
            border-color: var(--primary);
            transform: scale(1.05);
        }

        /* Sidebar */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 16px;
            overflow-y: auto;
            padding-right: 8px;
        }

        .sidebar::-webkit-scrollbar {
            width: 6px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: var(--border-light);
            border-radius: 3px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            border: 1px solid var(--border);
            padding: 20px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .card:hover {
            border-color: var(--border-light);
        }

        .card-title {
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-dim);
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .card-title::before {
            content: '';
            width: 4px;
            height: 16px;
            background: linear-gradient(180deg, var(--primary) 0%, var(--secondary) 100%);
            border-radius: 2px;
        }

        /* Upload Section */
        .upload-zone {
            border: 2px dashed var(--border-light);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 12px;
        }

        .upload-zone:hover, .upload-zone.dragover {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.05);
        }

        .upload-zone.loaded {
            border-color: var(--success);
            background: rgba(52, 211, 153, 0.05);
        }

        .upload-icon {
            font-size: 32px;
            margin-bottom: 8px;
        }

        .upload-text {
            font-size: 13px;
            font-weight: 600;
            color: var(--text);
            margin-bottom: 4px;
        }

        .upload-hint {
            font-size: 11px;
            color: var(--text-dim);
        }

        .file-input {
            display: none;
        }

        .file-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 14px;
            background: var(--input-bg);
            border-radius: 10px;
            font-size: 12px;
            color: var(--text-muted);
        }

        .file-status.loaded {
            color: var(--success);
        }

        .file-status-icon {
            font-size: 16px;
        }

        /* Stats */
        .stats-grid {
            display: grid;
            gap: 12px;
        }

        .stat-card {
            background: var(--input-bg);
            border-radius: 12px;
            padding: 16px;
            display: flex;
            align-items: center;
            gap: 14px;
            transition: all 0.3s;
            border: 1px solid transparent;
        }

        .stat-card:hover {
            transform: translateX(4px);
            border-color: var(--border-light);
        }

        .stat-icon {
            width: 44px;
            height: 44px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }

        .stat-icon.distance { background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); }
        .stat-icon.trucks { background: linear-gradient(135deg, #22d3ee 0%, #06b6d4 100%); }
        .stat-icon.segments { background: linear-gradient(135deg, #f472b6 0%, #ec4899 100%); }
        .stat-icon.time { background: linear-gradient(135deg, #34d399 0%, #10b981 100%); }

        .stat-info {
            flex: 1;
        }

        .stat-value {
            font-size: 20px;
            font-weight: 700;
            color: var(--text);
            line-height: 1.2;
        }

        .stat-label {
            font-size: 11px;
            color: var(--text-dim);
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Legend */
        .legend-grid {
            display: grid;
            gap: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 14px;
            background: var(--input-bg);
            border-radius: 10px;
            transition: all 0.2s;
        }

        .legend-item:hover {
            background: var(--card-bg-hover);
        }

        .legend-icon {
            font-size: 22px;
            width: 32px;
            text-align: center;
        }

        .legend-text {
            font-size: 13px;
            font-weight: 500;
            color: var(--text-muted);
        }

        /* Fleet Legend */
        .fleet-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .fleet-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            background: var(--input-bg);
            border-radius: 10px;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-muted);
            transition: all 0.2s;
        }

        .fleet-item:hover {
            transform: scale(1.02);
        }

        .fleet-color {
            width: 14px;
            height: 14px;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        /* Main Canvas Area */
        .main-content {
            display: flex;
            flex-direction: column;
            gap: 16px;
            min-height: 0;
        }

        .canvas-container {
            flex: 1;
            background: var(--card-bg);
            border-radius: 20px;
            border: 1px solid var(--border);
            position: relative;
            overflow: hidden;
            min-height: 400px;
        }

        .canvas-inner {
            position: absolute;
            inset: 0;
            background: var(--map-bg);
            border-radius: 19px;
        }

        canvas {
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        canvas:active {
            cursor: grabbing;
        }

        /* Empty State */
        .empty-state {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 40px;
        }

        .empty-icon {
            font-size: 80px;
            margin-bottom: 24px;
            opacity: 0.6;
        }

        .empty-title {
            font-size: 24px;
            font-weight: 700;
            color: var(--text);
            margin-bottom: 12px;
        }

        .empty-desc {
            font-size: 14px;
            color: var(--text-muted);
            max-width: 400px;
            line-height: 1.6;
        }

        /* Map Overlay Info */
        .map-overlay {
            position: absolute;
            top: 16px;
            right: 16px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .overlay-badge {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 10px 14px;
            font-size: 12px;
            font-weight: 600;
            color: var(--text);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .overlay-badge .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--success);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }

        /* Controls Bar */
        .controls-bar {
            grid-column: 1 / -1;
            background: var(--card-bg);
            border-radius: 16px;
            border: 1px solid var(--border);
            padding: 16px 24px;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .btn {
            height: 48px;
            padding: 0 24px;
            border-radius: 12px;
            border: none;
            font-family: inherit;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary) 0%, #8b5cf6 100%);
            color: white;
            box-shadow: 0 4px 15px var(--primary-glow);
            min-width: 120px;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px var(--primary-glow);
        }

        .btn-primary.playing {
            background: linear-gradient(135deg, var(--danger) 0%, #f43f5e 100%);
            box-shadow: 0 4px 15px rgba(248, 113, 113, 0.4);
        }

        .btn-icon {
            width: 48px;
            height: 48px;
            padding: 0;
            background: var(--input-bg);
            color: var(--text);
            border: 1px solid var(--border);
        }

        .btn-icon:hover {
            background: var(--card-bg-hover);
            border-color: var(--primary);
        }

        /* Timeline */
        .timeline-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .timeline-header {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            font-weight: 600;
        }

        .timeline-progress {
            color: var(--text);
        }

        .timeline-speed {
            color: var(--secondary);
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: var(--input-bg);
            border-radius: 4px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            cursor: pointer;
            box-shadow: 0 2px 10px var(--primary-glow);
            transition: transform 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        /* Speed Control */
        .speed-control {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 0 16px;
            border-left: 1px solid var(--border);
        }

        .speed-label {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-dim);
            white-space: nowrap;
        }

        .speed-slider {
            width: 100px;
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 12px 16px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 100;
            backdrop-filter: blur(10px);
            box-shadow: var(--shadow);
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto 1fr auto;
            }

            .sidebar {
                flex-direction: row;
                flex-wrap: wrap;
                overflow-x: auto;
                padding-right: 0;
                padding-bottom: 8px;
            }

            .sidebar .card {
                flex: 1;
                min-width: 280px;
            }

            .controls-bar {
                flex-wrap: wrap;
            }
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .card {
            animation: fadeIn 0.5s ease-out;
        }

        .card:nth-child(1) { animation-delay: 0.1s; }
        .card:nth-child(2) { animation-delay: 0.2s; }
        .card:nth-child(3) { animation-delay: 0.3s; }
        .card:nth-child(4) { animation-delay: 0.4s; }
    </style>
</head>
<body>
    <div class="bg-pattern"></div>
    
    <div class="container">
        <!-- Header -->
        <header class="header">
            <div class="logo">
                <div class="logo-icon">üöõ</div>
                <div class="logo-text">
                    <h1>VRP Visualizer</h1>
                    <span>Petroleum Distribution Optimizer</span>
                </div>
            </div>
            <div class="header-actions">
                <button class="theme-toggle" onclick="toggleTheme()" title="Toggle Theme">
                    <span id="themeIcon">üåô</span>
                </button>
            </div>
        </header>

        <!-- Sidebar -->
        <aside class="sidebar">
            <!-- Upload Card -->
            <div class="card">
                <div class="card-title">üìÅ Data Import</div>
                
                <div class="upload-zone" id="instanceZone" onclick="document.getElementById('instanceUpload').click()">
                    <div class="upload-icon">üìã</div>
                    <div class="upload-text">Instance File</div>
                    <div class="upload-hint">Drop .dat or .json</div>
                </div>
                <input type="file" id="instanceUpload" class="file-input" accept=".json,.dat,.txt">
                <div class="file-status" id="instanceStatus">
                    <span class="file-status-icon">‚è≥</span>
                    <span>No instance loaded</span>
                </div>

                <div class="upload-zone" id="solutionZone" onclick="document.getElementById('solutionUpload').click()" style="margin-top: 16px;">
                    <div class="upload-icon">üéØ</div>
                    <div class="upload-text">Solution File</div>
                    <div class="upload-hint">Drop .dat, .json or click to browse</div>
                </div>
                <input type="file" id="solutionUpload" class="file-input" accept=".json,.dat,.txt">
                <div class="file-status" id="solutionStatus">
                    <span class="file-status-icon">‚è≥</span>
                    <span>No solution loaded</span>
                </div>
            </div>

            <!-- Stats Card -->
            <div class="card">
                <div class="card-title">üìä Solution Metrics</div>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-icon distance">üìè</div>
                        <div class="stat-info">
                            <div class="stat-value" id="stat-dist">0.00 km</div>
                            <div class="stat-label">Total Distance</div>
                        </div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-icon trucks">üöõ</div>
                        <div class="stat-info">
                            <div class="stat-value" id="stat-trucks">0</div>
                            <div class="stat-label">Active Trucks</div>
                        </div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-icon segments">üõ§Ô∏è</div>
                        <div class="stat-info">
                            <div class="stat-value" id="stat-segments">0</div>
                            <div class="stat-label">Route Segments</div>
                        </div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-icon time">‚è±Ô∏è</div>
                        <div class="stat-info">
                            <div class="stat-value" id="stat-status">-</div>
                            <div class="stat-label">Solver Status</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Map Legend -->
            <div class="card">
                <div class="card-title">üó∫Ô∏è Map Legend</div>
                <div class="legend-grid">
                    <div class="legend-item">
                        <span class="legend-icon">üè¢</span>
                        <span class="legend-text">Garage (Start/End)</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-icon">üè≠</span>
                        <span class="legend-text">Depot (Source)</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-icon">‚õΩ</span>
                        <span class="legend-text">Station (Client)</span>
                    </div>
                </div>
            </div>

            <!-- Fleet Legend -->
            <div class="card">
                <div class="card-title">üöö Fleet Status</div>
                <div class="fleet-grid" id="fleet-legend">
                    <div class="fleet-item" style="grid-column: 1/-1; justify-content: center; color: var(--text-dim);">
                        Load a solution to see fleet
                    </div>
                </div>
            </div>
        </aside>

        <!-- Main Canvas -->
        <main class="main-content">
            <div class="canvas-container">
                <div class="canvas-inner">
                    <canvas id="canvas"></canvas>
                </div>
                
                <div class="empty-state" id="emptyState">
                    <div class="empty-icon">üó∫Ô∏è</div>
                    <div class="empty-title">Ready to Visualize</div>
                    <div class="empty-desc">
                        Upload an instance file and its solution to see the optimized vehicle routes come to life with smooth animations.
                    </div>
                </div>

                <div class="map-overlay" id="mapOverlay" style="display: none;">
                    <div class="overlay-badge">
                        <span class="dot"></span>
                        <span id="overlayStatus">Ready</span>
                    </div>
                </div>

                <div id="tooltip" class="tooltip"></div>
            </div>
        </main>

        <!-- Controls -->
        <div class="controls-bar">
            <div class="control-group">
                <button class="btn btn-primary" id="playBtn" onclick="togglePlay()">
                    <span id="playIcon">‚ñ∂</span>
                    <span id="playText">Play</span>
                </button>
                <button class="btn btn-icon" onclick="reset()" title="Reset">‚Ü∫</button>
                <button class="btn btn-icon" onclick="stepBackward()" title="Step Back">‚èÆ</button>
                <button class="btn btn-icon" onclick="stepForward()" title="Step Forward">‚è≠</button>
            </div>

            <div class="timeline-container">
                <div class="timeline-header">
                    <span class="timeline-progress" id="progressText">Step 0 / 0</span>
                    <span class="timeline-speed" id="speedText">1.0x</span>
                </div>
                <input type="range" id="timeline" min="0" max="1" step="0.001" value="0" oninput="seek(this.value)">
            </div>

            <div class="speed-control">
                <span class="speed-label">Speed</span>
                <input type="range" class="speed-slider" min="0.25" max="4" step="0.25" value="1" oninput="setSpeed(this.value)">
            </div>
        </div>
    </div>

    <script>
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // STATE MANAGEMENT
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        let instance = { locations: {}, demands: [] };
        let solution = { routes: {}, objective: 0 };
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        // Cached transform from instance coordinates to screen coordinates
        let coordTransform = null;
        
        let isPlaying = false;
        let progress = 0;
        let speed = 1;
        let maxProgress = 0;
        let animationId;
        let lastTime = 0;
        let trucks = [];
        let stationDemands = {};
        let stationVisits = {};
        let dataLoaded = false;

        const TRUCK_COLORS = [
            '#6366f1', '#22d3ee', '#f472b6', '#34d399', '#fbbf24',
            '#f87171', '#a78bfa', '#2dd4bf', '#fb923c', '#e879f9'
        ];

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // THEME MANAGEMENT
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        function toggleTheme() {
            const html = document.documentElement;
            const current = html.getAttribute('data-theme');
            const next = current === 'light' ? 'dark' : 'light';
            html.setAttribute('data-theme', next);
            document.getElementById('themeIcon').textContent = next === 'light' ? '‚òÄÔ∏è' : 'üåô';
            draw();
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // FILE UPLOAD HANDLING
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        function setupDragDrop(zoneId, inputId, type) {
            const zone = document.getElementById(zoneId);
            const input = document.getElementById(inputId);

            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                zone.addEventListener(eventName, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                });
            });

            ['dragenter', 'dragover'].forEach(eventName => {
                zone.addEventListener(eventName, () => zone.classList.add('dragover'));
            });

            ['dragleave', 'drop'].forEach(eventName => {
                zone.addEventListener(eventName, () => zone.classList.remove('dragover'));
            });

            zone.addEventListener('drop', (e) => {
                const file = e.dataTransfer.files[0];
                if (file) handleFile(file, type);
            });

            input.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) handleFile(file, type);
            });
        }

        function handleFile(file, type) {
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const content = event.target.result;
                    if (type === 'instance') {
                        if (file.name.endsWith('.dat') || file.name.endsWith('.txt')) {
                            instance = parseDatInstance(content);
                        } else {
                            instance = JSON.parse(content);
                        }
                        updateFileStatus('instance', file.name);
                    } else {
                        if (file.name.endsWith('.dat') || file.name.endsWith('.txt')) {
                            solution = parseDatSolution(content);
                        } else {
                            solution = JSON.parse(content);
                        }
                        updateFileStatus('solution', file.name);
                    }
                    initData();
                    resize();
                } catch (err) {
                    alert('Error parsing file: ' + err.message);
                    console.error(err);
                }
            };
            reader.readAsText(file);
        }

        function parseDatInstance(text) {
            const lines = text.trim().split('\n').map(l => l.trim()).filter(l => l && !l.startsWith('#'));
            let lineIdx = 0;

            // Dimensions
            // Two conventions exist in the project history:
            //  A) num_products num_depots num_garages num_stations num_vehicles  (used by core/model parser)
            //  B) num_vehicles num_depots num_garages num_stations num_products  (seen in some docs)
            // We auto-detect by validating the change-cost matrix shape.
            const dims = lines[lineIdx++].split(/\s+/).map(Number);
            if (dims.length !== 5 || dims.some(n => Number.isNaN(n))) {
                throw new Error('Invalid dimensions line in instance .dat');
            }

            const candidates = [
                {
                    name: 'products-first',
                    numProducts: dims[0],
                    numDepots: dims[1],
                    numGarages: dims[2],
                    numStations: dims[3],
                    numVehicles: dims[4]
                },
                {
                    name: 'vehicles-first',
                    numVehicles: dims[0],
                    numDepots: dims[1],
                    numGarages: dims[2],
                    numStations: dims[3],
                    numProducts: dims[4]
                }
            ];

            function matrixLooksValid(startIdx, n) {
                if (!Number.isFinite(n) || n <= 0) return false;
                if (startIdx + n > lines.length) return false;
                for (let r = 0; r < n; r++) {
                    const row = lines[startIdx + r].split(/\s+/).filter(Boolean);
                    if (row.length < n) return false;
                    if (row.slice(0, n).some(v => Number.isNaN(parseFloat(v)))) return false;
                }
                return true;
            }

            const chosen = candidates.find(c => matrixLooksValid(lineIdx, c.numProducts)) || candidates[0];
            const { numVehicles, numDepots, numProducts, numStations, numGarages } = chosen;

            // Skip Change Costs (numProducts lines)
            lineIdx += numProducts;

            // Skip Vehicles (numVehicles lines)
            lineIdx += numVehicles;

            const locations = {};
            const demands = [];

            // Parse Depots
            for (let i = 0; i < numDepots; i++) {
                const parts = lines[lineIdx++].split(/\s+/);
                const id = parts[0];
                const x = parseFloat(parts[1]);
                const y = parseFloat(parts[2]);
                locations[`D${id}`] = [x, y];
            }

            // Parse Garages
            for (let i = 0; i < numGarages; i++) {
                const parts = lines[lineIdx++].split(/\s+/);
                const id = parts[0];
                const x = parseFloat(parts[1]);
                const y = parseFloat(parts[2]);
                locations[`G${id}`] = [x, y];
            }

            // Parse Stations
            for (let i = 0; i < numStations; i++) {
                const parts = lines[lineIdx++].split(/\s+/);
                const id = parts[0];
                const x = parseFloat(parts[1]);
                const y = parseFloat(parts[2]);
                locations[`S${id}`] = [x, y];

                // Sum demands for visualization
                let totalDemand = 0;
                for (let p = 0; p < numProducts; p++) {
                    totalDemand += parseFloat(parts[3 + p] || 0);
                }
                demands.push({ station: `S${id}`, quantity: totalDemand });
            }

            return { 
                locations, 
                demands,
                num_vehicles: numVehicles,
                num_depots: numDepots,
                num_products: numProducts,
                num_stations: numStations,
                num_garages: numGarages
            };
        }

        function parseDatSolution(text) {
            const lines = text.trim().split('\n').map(l => l.trim()).filter(l => l);
            let lineIdx = 0;
            
            const solution = {
                routes: {},
                metrics: {}
            };
            
            // Parse vehicle routes until we reach metrics
            while (lineIdx < lines.length) {
                const line = lines[lineIdx];
                
                // Check if this is a vehicle line in format "ID: <route>"
                const idMatch = line.match(/^\s*(\d+)\s*:\s*(.*)$/);
                if (idMatch) {
                    const vehicleId = parseInt(idMatch[1]);
                    // route content after the colon
                    let routeLine = idMatch[2].trim();
                    lineIdx++;

                    // Find next non-empty line for products
                    while (lineIdx < lines.length && lines[lineIdx].trim() === '') {
                        lineIdx++;
                    }
                    if (lineIdx >= lines.length) break;

                    let productsLineRaw = lines[lineIdx].trim();
                    // Remove optional "ID: " prefix from products line
                    productsLineRaw = productsLineRaw.replace(/^\s*\d+\s*:\s*/, '');
                    lineIdx++;

                    // Parse the route (split by " - ") and build segments
                    const routeParts = routeLine.split(' - ').map(p => p.trim());
                    const segments = [];

                    const extractNodeId = (token, position, lastPosition) => {
                        // Token may be: "12", "12 [..]", "12 (..)", or typed "G2"/"D1"/"S5".
                        const raw = String(token).trim();
                        const base = raw.split('[', 1)[0].split('(', 1)[0].trim();

                        const typed = base.match(/^([GDS])(\d+)$/i);
                        if (typed) {
                            return `${typed[1].toUpperCase()}${parseInt(typed[2], 10)}`;
                        }

                        const numeric = base.match(/^(?:N)?(\d+)$/);
                        if (!numeric) return null;
                        const n = parseInt(numeric[1], 10);

                        // New convention (no prefixes): infer by markers/position.
                        if (raw.includes('[')) return `D#${n}`;
                        if (raw.includes('(')) return `S#${n}`;
                        if (position === 0 || position === lastPosition) return `G#${n}`;
                        // Default: treat as garage token (rare), keep marker so mapping can decide.
                        return `G#${n}`;
                    };

                    const lastPos = routeParts.length - 1;
                    for (let i = 0; i < routeParts.length - 1; i++) {
                        const current = routeParts[i];
                        const next = routeParts[i + 1];

                        const fromId = extractNodeId(current, i, lastPos);
                        const toId = extractNodeId(next, i + 1, lastPos);

                        if (fromId && toId) {
                            segments.push([fromId, toId]);
                        }
                    }

                    solution.routes[`V${vehicleId}`] = segments;

                    // Skip empty line separators
                    while (lineIdx < lines.length && lines[lineIdx].trim() === '') {
                        lineIdx++;
                    }
                } else {
                    // We've reached the metrics section
                    break;
                }
            }
            
            // Parse metrics (last 6 lines)
            if (lineIdx + 5 < lines.length) {
                solution.metrics = {
                    vehicles_used: parseInt(lines[lineIdx]),
                    product_changes: parseInt(lines[lineIdx + 1]),
                    routing_cost: parseFloat(lines[lineIdx + 2]),
                    total_cost: parseFloat(lines[lineIdx + 3]),
                    solver: lines[lineIdx + 4],
                    time: parseFloat(lines[lineIdx + 5])
                };
                
                solution.objective = solution.metrics.total_cost;
                solution.status = 'Solved';
            }
            
            return solution;
        }

        function mapNodeNumber(nodeStr, numGarages, numDepots, numStations) {
            // If already typed, pass through
            const typed = String(nodeStr).match(/^([GDS])(\d+)$/i);
            if (typed) return `${typed[1].toUpperCase()}${parseInt(typed[2], 10)}`;

            // Internal marked tokens from parseDatSolution: G#12 / D#3 / S#5
            const marked = String(nodeStr).match(/^([GDS])#(\d+)$/i);
            if (marked) {
                const kind = marked[1].toUpperCase();
                const n = parseInt(marked[2], 10);

                // If n fits the natural range for the kind, use it directly (no accumulation)
                if (kind === 'G' && n <= numGarages) return `G${n}`;
                if (kind === 'D' && n <= numDepots) return `D${n}`;
                if (kind === 'S' && n <= numStations) return `S${n}`;

                // Otherwise assume legacy offset numeric and map by accumulation
                if (kind === 'G') return (n <= numGarages) ? `G${n}` : `G${Math.max(1, n)}`;
                if (kind === 'D') {
                    if (n <= numGarages + numDepots) return `D${n - numGarages}`;
                    return `D${Math.max(1, n - numGarages)}`;
                }
                // S
                return `S${Math.max(1, n - numGarages - numDepots)}`;
            }

            // Accept both "N123" and "123"
            const match = String(nodeStr).match(/^(?:N)?(\d+)$/);
            if (!match) return nodeStr;

            const nodeNum = parseInt(match[1], 10);
            
            if (nodeNum <= numGarages) {
                return `G${nodeNum}`;
            } else if (nodeNum <= numGarages + numDepots) {
                return `D${nodeNum - numGarages}`;
            } else {
                return `S${nodeNum - numGarages - numDepots}`;
            }
        }

        function updateFileStatus(type, filename) {
            const statusEl = document.getElementById(type + 'Status');
            const zoneEl = document.getElementById(type + 'Zone');
            statusEl.innerHTML = `<span class="file-status-icon">‚úÖ</span><span>${filename}</span>`;
            statusEl.classList.add('loaded');
            zoneEl.classList.add('loaded');
        }

        setupDragDrop('instanceZone', 'instanceUpload', 'instance');
        setupDragDrop('solutionZone', 'solutionUpload', 'solution');

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // DATA INITIALIZATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        function initData() {
            trucks = [];
            maxProgress = 0;
            progress = 0;
            isPlaying = false;
            stationDemands = {};
            stationVisits = {};
            updatePlayBtn();

            // Process Demands
            (instance.demands || []).forEach(d => {
                stationDemands[d.station] = (stationDemands[d.station] || 0) + d.quantity;
            });

            // Get instance dimensions for node mapping
            const numGarages = instance.num_garages || 3;
            const numDepots = instance.num_depots || 2; 
            const numStations = instance.num_stations || 5;

            // Process Routes
            Object.entries(solution.routes || {}).forEach(([id, segments], idx) => {
                if (!segments || segments.length === 0) return;

                // Convert node numbers to proper IDs
                const convertedSegments = segments.map(([from, to]) => {
                    const fromId = mapNodeNumber(from, numGarages, numDepots, numStations);
                    const toId = mapNodeNumber(to, numGarages, numDepots, numStations);
                    return [fromId, toId];
                });

                trucks.push({
                    id,
                    color: TRUCK_COLORS[idx % TRUCK_COLORS.length],
                    segments: convertedSegments,
                    totalDist: 0
                });

                convertedSegments.forEach(([from, to]) => {
                    if (to && to.startsWith('S')) {
                        stationVisits[to] = (stationVisits[to] || 0) + 1;
                    }
                });

                maxProgress = Math.max(maxProgress, convertedSegments.length);
            });

            // Update Stats
            const metrics = solution.metrics || {};
            document.getElementById('stat-dist').textContent = (metrics.total_cost || solution.objective || 0).toFixed(2) + ' km';
            document.getElementById('stat-trucks').textContent = metrics.vehicles_used || trucks.length;
            
            let totalSegs = trucks.reduce((sum, t) => sum + t.segments.length, 0);
            document.getElementById('stat-segments').textContent = totalSegs;
            document.getElementById('stat-status').textContent = solution.status || 'Loaded';

            // Update Fleet Legend
            const legendEl = document.getElementById('fleet-legend');
            if (trucks.length > 0) {
                legendEl.innerHTML = trucks.map(t => `
                    <div class="fleet-item">
                        <div class="fleet-color" style="background: ${t.color}"></div>
                        <span>${t.id}</span>
                    </div>
                `).join('');
            } else {
                legendEl.innerHTML = `
                    <div class="fleet-item" style="grid-column: 1/-1; justify-content: center; color: var(--text-dim);">
                        Load a solution to see fleet
                    </div>
                `;
            }

            // Update UI State
            dataLoaded = Object.keys(instance.locations).length > 0 && trucks.length > 0;
            document.getElementById('emptyState').style.display = dataLoaded ? 'none' : 'flex';
            document.getElementById('mapOverlay').style.display = dataLoaded ? 'flex' : 'none';
            
            updateUI();
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // CANVAS & DRAWING
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        function resize() {
            const container = canvas.parentElement;
            const dpr = window.devicePixelRatio || 1;
            
            canvas.width = container.clientWidth * dpr;
            canvas.height = container.clientHeight * dpr;
            canvas.style.width = container.clientWidth + 'px';
            canvas.style.height = container.clientHeight + 'px';

            // Reset transform before applying device-pixel scaling; otherwise it accumulates
            // and the drawing progressively shrinks/grows on each resize.
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.scale(dpr, dpr);
            
            width = container.clientWidth;
            height = container.clientHeight;

            computeCoordTransform();
            
            draw();
        }

        window.addEventListener('resize', resize);

        function computeCoordTransform() {
            if (!instance.locations || Object.keys(instance.locations).length === 0 || !width || !height) {
                coordTransform = null;
                return;
            }

            // Compute tight bounds then add 10% margin on each axis (world-units)
            const allPoints = Object.values(instance.locations);
            const allX = allPoints.map(p => p[0]);
            const allY = allPoints.map(p => p[1]);
            const rawMinX = Math.min(...allX), rawMaxX = Math.max(...allX);
            const rawMinY = Math.min(...allY), rawMaxY = Math.max(...allY);

            const rawW = rawMaxX - rawMinX;
            const rawH = rawMaxY - rawMinY;
            const marginX = rawW > 0 ? 0.1 * rawW : 1;
            const marginY = rawH > 0 ? 0.1 * rawH : 1;

            const minX = rawMinX - marginX;
            const maxX = rawMaxX + marginX;
            const minY = rawMinY - marginY;
            const maxY = rawMaxY + marginY;

            const worldW = (maxX - minX) || 1;
            const worldH = (maxY - minY) || 1;

            // Fit to canvas while keeping aspect ratio
            const scale = Math.min(width / worldW, height / worldH);

            // Center the drawing area
            const offsetX = (width - worldW * scale) / 2;
            const offsetY = (height - worldH * scale) / 2;

            coordTransform = { minX, minY, scale, offsetX, offsetY };
        }

        function getCoords(locId) {
            if (!instance.locations || !instance.locations[locId]) return { x: 0, y: 0 };

            if (!coordTransform) {
                computeCoordTransform();
            }
            if (!coordTransform) {
                return { x: 0, y: 0 };
            }

            const [x, y] = instance.locations[locId];
            const { minX, minY, scale, offsetX, offsetY } = coordTransform;

            const screenX = offsetX + (x - minX) * scale;
            const screenY = offsetY + (y - minY) * scale;
            return { x: screenX, y: screenY };
        }

        function getThemeColor(varName) {
            return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
        }

        function drawGrid() {
            const gridSize = 40;
            ctx.strokeStyle = getThemeColor('--grid-color');
            ctx.lineWidth = 1;

            for (let x = 0; x <= width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }

            for (let y = 0; y <= height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
        }

        function getStationSatisfaction(stationId, currentProgress) {
            if (!stationDemands[stationId]) return 1;

            let visitsSoFar = 0;
            const totalVisits = stationVisits[stationId] || 1;

            trucks.forEach(t => {
                const completedSegs = Math.floor(Math.min(currentProgress, t.segments.length));
                for (let i = 0; i < completedSegs; i++) {
                    if (t.segments[i][1] === stationId) {
                        visitsSoFar++;
                    }
                }
            });

            return Math.min(1, visitsSoFar / totalVisits);
        }

        function drawNode(id, type) {
            const { x, y } = getCoords(id);

            // Glow effect
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, 35);
            if (type === 'garage') {
                gradient.addColorStop(0, 'rgba(99, 102, 241, 0.3)');
            } else if (type === 'depot') {
                gradient.addColorStop(0, 'rgba(34, 211, 238, 0.3)');
            } else {
                gradient.addColorStop(0, 'rgba(244, 114, 182, 0.3)');
            }
            gradient.addColorStop(1, 'transparent');

            ctx.beginPath();
            ctx.arc(x, y, 35, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Base circle
            ctx.beginPath();
            ctx.arc(x, y, 22, 0, Math.PI * 2);
            ctx.fillStyle = getThemeColor('--node-bg');
            ctx.fill();
            ctx.strokeStyle = getThemeColor('--border-light');
            ctx.lineWidth = 2;
            ctx.stroke();

            // Icon
            ctx.font = '22px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            let icon = type === 'garage' ? 'üè¢' : type === 'depot' ? 'üè≠' : '‚õΩ';
            ctx.fillText(icon, x, y + 1);

            // Label
            ctx.font = '600 11px Inter';
            ctx.fillStyle = getThemeColor('--text');
            ctx.fillText(id, x, y + 38);

            // Demand bar for stations
            if (type === 'station') {
                const satisfaction = getStationSatisfaction(id, progress);
                const demand = stationDemands[id] || 0;
                
                if (demand > 0) {
                    const barWidth = 44;
                    const barHeight = 6;
                    const barX = x - barWidth / 2;
                    const barY = y + 48;

                    // Background
                    ctx.fillStyle = getThemeColor('--input-bg');
                    ctx.beginPath();
                    ctx.roundRect(barX, barY, barWidth, barHeight, 3);
                    ctx.fill();

                    // Progress
                    const fillColor = satisfaction >= 1 ? '#34d399' : '#fbbf24';
                    ctx.fillStyle = fillColor;
                    ctx.beginPath();
                    ctx.roundRect(barX, barY, barWidth * satisfaction, barHeight, 3);
                    ctx.fill();

                    // Text
                    ctx.font = '500 9px Inter';
                    ctx.fillStyle = getThemeColor('--text-dim');
                    ctx.fillText(`${Math.floor(demand * satisfaction)}/${demand}`, x, barY + 16);
                }
            }
        }

        function drawTruck(truck, currentProgress) {
            if (truck.segments.length === 0) return;

            let activeSegmentIdx = Math.floor(currentProgress);
            let t = currentProgress - activeSegmentIdx;

            if (activeSegmentIdx >= truck.segments.length) {
                activeSegmentIdx = truck.segments.length - 1;
                t = 1;
            }

            const [startId, endId] = truck.segments[activeSegmentIdx];
            const start = getCoords(startId);
            const end = getCoords(endId);

            const curX = start.x + (end.x - start.x) * t;
            const curY = start.y + (end.y - start.y) * t;

            // Draw completed route
            ctx.strokeStyle = truck.color;
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.setLineDash([]);

            ctx.beginPath();
            for (let i = 0; i < activeSegmentIdx; i++) {
                const [s, e] = truck.segments[i];
                const p1 = getCoords(s);
                const p2 = getCoords(e);
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
            }
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(curX, curY);
            ctx.stroke();

            // Draw remaining route (dashed)
            ctx.setLineDash([8, 8]);
            ctx.strokeStyle = truck.color + '40';
            ctx.beginPath();
            ctx.moveTo(curX, curY);
            ctx.lineTo(end.x, end.y);
            for (let i = activeSegmentIdx + 1; i < truck.segments.length; i++) {
                const [s, e] = truck.segments[i];
                const p1 = getCoords(s);
                const p2 = getCoords(e);
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw truck
            ctx.save();
            ctx.translate(curX, curY);

            const angle = Math.atan2(end.y - start.y, end.x - start.x);
            ctx.rotate(angle);

            // Glow
            const glow = ctx.createRadialGradient(0, 0, 0, 0, 0, 25);
            glow.addColorStop(0, truck.color + '60');
            glow.addColorStop(1, 'transparent');
            ctx.fillStyle = glow;
            ctx.beginPath();
            ctx.arc(0, 0, 25, 0, Math.PI * 2);
            ctx.fill();

            // Body
            ctx.fillStyle = truck.color;
            ctx.beginPath();
            ctx.roundRect(-16, -10, 26, 20, 5);
            ctx.fill();

            // Cabin
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.beginPath();
            ctx.roundRect(2, -7, 7, 14, 2);
            ctx.fill();

            // Wheels
            ctx.fillStyle = '#1a1a2e';
            ctx.beginPath();
            ctx.arc(-9, 12, 4, 0, Math.PI * 2);
            ctx.arc(4, 12, 4, 0, Math.PI * 2);
            ctx.arc(-9, -12, 4, 0, Math.PI * 2);
            ctx.arc(4, -12, 4, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function draw() {
            ctx.clearRect(0, 0, width, height);

            if (!dataLoaded) return;

            drawGrid();

            // Draw all routes first (background)
            trucks.forEach(truck => {
                if (truck.segments.length === 0) return;
                
                ctx.strokeStyle = truck.color + '20';
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                
                truck.segments.forEach(([s, e]) => {
                    const p1 = getCoords(s);
                    const p2 = getCoords(e);
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                });
                ctx.stroke();
                ctx.setLineDash([]);
            });

            // Draw nodes
            Object.keys(instance.locations).forEach(id => {
                let type = 'station';
                if (id.startsWith('G')) type = 'garage';
                if (id.startsWith('D')) type = 'depot';
                drawNode(id, type);
            });

            // Draw trucks on top
            trucks.forEach(truck => drawTruck(truck, progress));

            // Update overlay
            document.getElementById('overlayStatus').textContent = 
                isPlaying ? 'Animating...' : `Step ${Math.floor(progress)} of ${maxProgress}`;
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ANIMATION & CONTROLS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        function animate(timestamp) {
            if (!isPlaying) return;
            if (!lastTime) lastTime = timestamp;

            const dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            progress += dt * speed;

            if (progress >= maxProgress) {
                progress = maxProgress;
                isPlaying = false;
                updatePlayBtn();
            }

            updateUI();
            draw();

            if (isPlaying) {
                animationId = requestAnimationFrame(animate);
            }
        }

        function togglePlay() {
            if (!dataLoaded) return;
            
            isPlaying = !isPlaying;
            updatePlayBtn();
            
            if (isPlaying) {
                lastTime = 0;
                if (progress >= maxProgress) progress = 0;
                animationId = requestAnimationFrame(animate);
            } else {
                cancelAnimationFrame(animationId);
            }
        }

        function updatePlayBtn() {
            const btn = document.getElementById('playBtn');
            const icon = document.getElementById('playIcon');
            const text = document.getElementById('playText');

            if (isPlaying) {
                btn.classList.add('playing');
                icon.textContent = '‚è∏';
                text.textContent = 'Pause';
            } else {
                btn.classList.remove('playing');
                icon.textContent = '‚ñ∂';
                text.textContent = 'Play';
            }
        }

        function reset() {
            isPlaying = false;
            progress = 0;
            cancelAnimationFrame(animationId);
            updatePlayBtn();
            updateUI();
            draw();
        }

        function stepForward() {
            if (!dataLoaded) return;
            progress = Math.min(maxProgress, Math.floor(progress) + 1);
            updateUI();
            draw();
        }

        function stepBackward() {
            if (!dataLoaded) return;
            progress = Math.max(0, Math.ceil(progress) - 1);
            updateUI();
            draw();
        }

        function seek(val) {
            progress = parseFloat(val);
            updateUI();
            draw();
        }

        function setSpeed(val) {
            speed = parseFloat(val);
            document.getElementById('speedText').textContent = speed.toFixed(2) + 'x';
        }

        function updateUI() {
            const slider = document.getElementById('timeline');
            slider.max = maxProgress || 1;
            slider.value = progress;

            document.getElementById('progressText').textContent =
                `Step ${Math.floor(progress)} / ${maxProgress}`;
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // INITIALIZATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        resize();
        updateUI();
        draw();
    </script>
</body>
</html>
